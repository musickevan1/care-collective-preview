# Fix Plan: Integration Test Failures

> Generated by @prompt-builder on 2025-12-27
> Priority: HIGH
> Estimated Fix Time: 4-8 hours

## Original Issue

**Error:** `useRouter.mockReturnValue is not a function`
**Impact:** Cannot verify user journeys work end-to-end
**Root Cause:** Mock setup incompatible with Next.js 14 App Router
**Test Status:** 0% pass rate, 15 tests failing

## Root Cause Analysis

The integration tests are using an outdated mocking pattern for Next.js Router:

1. **Old pattern (Next.js 12/13):** `jest.mock('next/router')` with `useRouter.mockReturnValue()`
2. **Next.js 14 App Router:** Uses `next/navigation` instead of `next/router`
3. **Mocking issue:** The test setup likely references the wrong package or uses an incompatible mock API
4. **Additional issues:** Test setup may have other Next.js 14 incompatibilities (async components, server actions, etc.)

## Target Agent

`@test-engineer` - Unit, integration, E2E tests, test infrastructure

---

## Prompt

### Problem Statement

Integration tests are failing because the Next.js Router mock setup is incompatible with Next.js 14 App Router. The error `useRouter.mockReturnValue is not a function` indicates the test setup is using outdated patterns.

### Technical Context

- **Current Next.js version:** 14.2.32 with App Router
- **Router location:** App Router uses `next/navigation`, not `next/router`
- **Test runner:** Vitest (from project configuration)
- **Test library:** React Testing Library
- **Test location:** `tests/` directory
- **Priority:** Focus on getting existing 15 tests working first, not adding new ones

### Implementation Requirements

#### Phase 1: Analyze Test Setup (60 min)
1. Read test configuration files:
   - `vitest.config.ts`
   - `tests/setup.ts` or similar test setup file
   - `tests/utils.tsx` - Test utilities
2. Identify all failing tests:
   ```bash
   npm test -- tests/integration/ --run
   ```
3. For each failing test, identify the root cause:
   - Router mocking issues
   - Other Next.js 14 incompatibilities
4. Check if any test mocks are using `next/router` instead of `next/navigation`

#### Phase 2: Fix Next.js 14 App Router Mocks (90 min)
1. Update test setup to use Next.js 14 App Router patterns:
   ```typescript
   // tests/setup.ts or similar
   import { mockRouter } from './mocks/next-router'

   // Replace old mock with App Router compatible version
   ```
2. Create or update router mocks:
   ```typescript
   // tests/mocks/next-router.ts
   import { vi } from 'vitest'
   import { useRouter, usePathname, useSearchParams } from 'next/navigation'

   vi.mock('next/navigation')

   export function mockRouter(overrides = {}) {
     const router = {
       push: vi.fn(),
       replace: vi.fn(),
       prefetch: vi.fn(),
       back: vi.fn(),
       ...overrides,
     }

     useRouter.mockReturnValue(router)
     usePathname.mockReturnValue('/dashboard')
     useSearchParams.mockReturnValue(new URLSearchParams())

     return router
   }
   ```
3. Update all tests using `useRouter.mockReturnValue()` to use the new mock

#### Phase 3: Fix Other Next.js 14 Incompatibilities (120 min)
1. **Server Components:** Tests may need to be converted to Client Components
2. **Async Components:** Ensure tests handle async rendering properly
3. **Server Actions:** Mock server actions if present
4. **Suspense:** Add Suspense wrappers if components use Suspense
5. **Dynamic Data:** Provide proper mocks for data fetching

For each test:
1. Read the test file
2. Identify Next.js 14 incompatibility
3. Update test to work with App Router
4. Verify test passes

#### Phase 4: Prioritize Critical Tests (60 min)
Fix in this order (most important first):

1. **Auth flow tests:**
   - User can login
   - Protected routes redirect unauthenticated users
   - Dashboard loads after login

2. **Help request tests:**
   - Can create a help request
   - Can view help requests
   - Can filter/search help requests

3. **Basic messaging tests:**
   - Can view message list
   - Can send a message
   - Receive message notifications

#### Phase 5: Run Full Test Suite (30 min)
1. Run all tests to verify they pass:
   ```bash
   npm test -- --run
   ```
2. Check test coverage:
   ```bash
   npm run test:coverage
   ```
3. Document any tests that couldn't be fixed and explain why

### Acceptance Criteria

1. ✅ All 15 integration tests pass (or as many as possible)
2. ✅ Auth flow tests work: login → dashboard journey verified
3. ✅ Help request creation tests work
4. ✅ Basic messaging tests work
5. ✅ No `useRouter.mockReturnValue is not a function` errors
6. ✅ Test suite runs successfully: `npm test -- --run`
7. ✅ Test coverage remains at or above 80%

### Files to Modify

1. `tests/setup.ts` - Update Next.js 14 App Router mocks
2. `tests/mocks/next-router.ts` - Create or update router mocks
3. `tests/integration/*.test.tsx` - Fix individual test files
4. Any other test setup files

### Files to Read (Analysis)

1. `vitest.config.ts`
2. `tests/setup.ts`
3. `tests/utils.tsx`
4. All test files in `tests/integration/`
5. `package.json` - Check test dependencies

### Testing Strategy

1. **Run tests first:** Identify all failing tests before fixing
2. **Fix one at a time:** Fix and verify each test individually
3. **Incremental progress:** Test after each fix to ensure no regressions
4. **Full suite run:** Run all tests at the end to verify everything works

### Dependencies

- **Blocks on:** Middleware fix (must work first to test protected routes)
- **Blocks on:** Database types fix (some tests may type-check properly only after this)
- **No other dependencies:** Can proceed once middleware and types are fixed

### Potential Risks & Mitigation

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Some tests cannot be fixed without significant refactoring | Medium | Medium | Document which tests and why, skip temporarily |
| Next.js 14 API changes break test infrastructure | Low | High | Check Next.js 14 documentation for proper testing patterns |
| Test mocking introduces flakiness | Medium | Medium | Write robust mocks, test with multiple scenarios |
| Fixed tests pass but don't actually test what they should | Medium | High | Review each test to ensure it validates actual user behavior |

### Rollback Plan

If test fixes cause issues:
1. Keep original test files backed up
2. Revert to original test suite
3. Focus on getting a subset of critical tests working first

### Additional Context

- **Priority:** Fix existing 15 tests first, don't add new ones
- **Critical path:** Auth flow (login → dashboard), Help request creation, Basic messaging
- **Next.js 14 changes:** App Router fundamentally changed testing patterns
- **Test philosophy:** Focus on user journey validation, not implementation details

### Known Next.js 14 Test Patterns

```typescript
// Mocking useSearchParams
import { useSearchParams } from 'next/navigation'
vi.mock('next/navigation')
useSearchParams.mockReturnValue(new URLSearchParams('query=test'))

// Mocking useRouter
import { useRouter } from 'next/navigation'
const mockPush = vi.fn()
useRouter.mockReturnValue({ push: mockPush })

// Testing async components
import { act } from '@testing-library/react'
await act(async () => {
  render(<AsyncComponent />)
})

// Testing with Suspense
render(
  <Suspense fallback={<div>Loading...</div>}>
    <DataComponent />
  </Suspense>
)
```

### Questions for the Agent

1. Which of the 15 tests are most critical for launch?
2. Are there any tests that test server actions that need special handling?
3. Should we document the test patterns for future reference?

### Success Metrics

- Integration tests passing: Target 15/15 (minimum 12/15)
- Auth flow tests: 100% passing
- Help request tests: 100% passing
- Basic messaging tests: 100% passing
- Test coverage: ≥80%
